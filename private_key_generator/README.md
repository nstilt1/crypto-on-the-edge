# Private Key Generator

This library provides the core functionality of generating private keys from a user-provided ID. The IDs can contain an embedded expiration time and a truncated HMAC to determine probable authenticity. The HMAC can be computed with associated data, which can allow for an ID to only be used by a specific client. The associated data is also used for computing the private key.

# Security and Compatibility Notice

This library has not received an audit, and it is still a work in progress. If any changes are made in the core functionality of generating keys from IDs, or how the IDs or metadata are represented, it can and will break your code.

# Requirements
This library is compatible with `no-std`, but without `std`, this library's `validate_id` functions will not be able to validate the timestamps of IDs. However, if you are able to determine the current time in seconds since `UNIX_EPOCH`, you can call `get_expiration_time()` and manually validate the expiration time.

This library also depends on `RustCrypto`'s `elliptic_curves` with the following features enabled:
* `jwk` for generating unique private keys with the same ID for different curves
* `ecdh`

You might need to ensure that those features are enabled when you use other `RustCrypto` libraries' curves.

# Features

* `std` is enabled by default, which is required for validating embedded timestamps
* `long-timestamp-timespan` is enabled by default, which adds a byte to timestamps, allowing the timestamp to be used for a total span of 34,841 years ahead. If it is disabled, the maximum span is 136 years from a provided EPOCH.
* `lossy-timestamps` is disabled by default, and it will remove a byte from timestamps at the cost of not knowing the exact time the timestamp is meant to expire. The embedded expiration value will **always be between 129-384 seconds greater** than the originally provided expiration time. Some people might see that as a good thing.

# Intro

Using private keys for encryption and authentication in an application or service is a delicate process. You need to make sure that every step of the process is secure. This library assists with 4 aspects of private key management:

## Key generation

This library provides a `KeyGenerator` struct, and a `BinaryId` struct. The `BinaryId` is an array with a length that you specify, that contains an HMAC that you can specify the length of as well. The HMAC is used to validate the Key ID, or whatever kinds of IDs you wish to use.

The `KeyGenerator` can be initialized with a given hash function, an HMAC key, and an arbitrary "application ID," which are used to initialize the HKDF. Then you can provide a `BinaryId` to the `KeyGenerator` to create `ECDH` and `ECDSA` keys.

The `KeyGenerator` can also generate symmetric keys for encrypting items in your database with unique keys.

## Key storage

This library elimintates the necessity to store any keys generated by the `KeyGenerator` since they can be derived with the internal HKDF. There is only one key that needs to be saved, and that is the HMAC Key or PRK that is used within the HKDF. This is as secure as hard-coding any other type of private key. Some Key IDs might need to be stored, but they are not sensitive. 

## Key lifetimes

The `BinaryId` struct can accept a version number, which will be encoded in its metadata. The metadata is currently only 1 byte, and the maximum supported version is only 63, but this might change to use 2 bytes instead of 1 for the metadata. The version number can be changed to update the HMAC key or hash algorithm, or almost any other aspect about the ID or key generation mechanism. The only thing that you can't change easily between versions is the index of the metadata byte.

The `BinaryId` can also contain a 3-byte timestamp marking the expiration of the key ID. The compressed timestamp has the following limitations:
* it cannot represent a date further than 136 years from the `EPOCH` value you supply (which can be any past timestamp, refer to the `BinaryId` documentation)
* the timestamp will always be between 129-384 seconds ahead of the input expiration timestamp. This is useful for providing a small time extension.
* Timestamp validation requires the `std` feature. If this feature is disabled, an expired ID will pass validation, but there is a `get_expiration_time` method for decoding the expiration time if you have a way to get the current time.

## Switching between signature algorithms and hash functions for key generation

You could switch the version of your IDs to update some aspects of your cryptography, such as the:
* signature algorithm
* ID size
* hash function
* HMAC key
* `EPOCH` timestamp used in the compression

You will need to use the `get_version` method to attempt to extract the ID's version.

# Protocol Draft

This library serves as the core part of a protocol I am developing, where private keys can be automatically rotated without needing to save them anywhere. Due to the nature of IDs potentially using associated data... if you intend to use this library directly, consider making or using a crate that tries to abstract away this crate's peculiarities. I will try to make a library that depends on `std` and `prost`, but this might not suit your use case and it will require some predetermined protobuf messages.

The protocol is as follows:

Bob has a periodically updating webpage that contains some ECDSA and ECDH public keys and some associated key IDs. Bob also allows the use of a small set of AEADs for encrypting requests and responses.

Alice fetches a set of public keys and their associated key IDs and checks the TLS signature to make sure they're legit.

Alice sends a request to Bob with this information:
- an encrypted payload
- the specific AEAD algorithm that was used to encrypt the payload (which is also the algorithm that Alice wants Bob to use in the response)
- Alice's ECDH pubkey
- Alice's ECDSA pubkey
- Bob's ECDH key ID that was used to encrypt the payload, and an info and salt
- Bob's ECDSA key ID that Alice is expecting to receive a signature with
- timestamp, hash
- a signature made with the ECDSA pubkey

Bob determines:
- if the AEAD that Alice chose is sufficient (from Bob's predetermined list)
- if the key IDs are valid

Bob attempts to decrypt the payload, and responds with:
- info and salt used with ECDH
- Encrypted using the same ECDH key but using the above info and salt:
  - a Client ID for Alice to identify theirself with to Bob
  - the next ECDH key and ID for Alice to use in the next request, associated with Alice using Alice's Client ID
- timestamp, hash
- signature using the ECDSA key

Alice stores the ECDH key ID and pubkey in Alice's database to use with the next request.

Bob stores Alice's next ECDH Key ID in Bob's database, and after receiving a request from Alice the next time, adds a "last-used" timestamp next to the ECDH key ID, removing any ECDH key IDs associated with Alice that are older than a minute. This step could probably be ignored, but it could protect against replay attacks.

Bob is able to generate unique encryption keys for Bob's database using client IDs, and is also able to generate ECDSA private keys that are associated with a specific ID, which will be useful for making "Product IDs" that each have a unique private key associated, such as for licensing software. Software licensing will validate the server's public keys using 3 signatures:
1) the product's individual private key, which will be a static key
2) the server's ECDSA key that is rotating automatically
3) the TLS signature on the response