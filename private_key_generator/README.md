# Private Key Generator

This library provides the core functionality of generating private keys from a user-provided ID. The IDs can contain an embedded expiration time and a truncated HMAC to determine probable authenticity. The HMAC can be computed with associated data, which can allow for an ID to only be used by a specific client. The associated data is also used for computing the private key.

# Security and Compatibility Notice

This library has not received an audit, and it is still a work in progress. If any changes are made in the core functionality of generating keys from IDs, or how the IDs or metadata are represented, it can and will break your code.

# Requirements
This library is compatible with `no-std`, but without `std`, this library's `validate_id` functions will not be able to validate the timestamps of IDs. However, if you are able to determine the current time in seconds since `UNIX_EPOCH`, you can call `get_expiration_time()` and manually validate the expiration time.

This library also depends on `RustCrypto`'s `elliptic_curves` with the following features enabled:
* `jwk` for generating unique private keys with the same ID for different curves
* `ecdh`

You might need to ensure that those features are enabled when you use other `RustCrypto` libraries' curves.

# Features

* `std` is enabled by default, which is required for validating embedded timestamps
* `long-timestamp-timespan` is enabled by default, which adds a byte to timestamps, allowing the timestamp to be used for a total span of 34,841 years ahead. If it is disabled, the maximum span is 136 years from a provided EPOCH.
* `lossy-timestamps` is disabled by default, and it will remove a byte from timestamps at the cost of not knowing the exact time the timestamp is meant to expire. The embedded expiration value will **always be between 129-384 seconds greater** than the originally provided expiration time. Some people might see that as a good thing.

# Intro

Using private keys for encryption and authentication in an application or service is a delicate process. You need to make sure that every step of the process is secure. This library assists with 4 aspects of private key management:

## Key generation

This library provides a `KeyGenerator` struct, and a `BinaryId` struct. The `BinaryId` is an array with a length that you specify, that contains an HMAC that you can specify the length of as well. The HMAC is used to validate the Key ID, or whatever kinds of IDs you wish to use.

The `KeyGenerator` can be initialized with a given hash function, an HMAC key, and an arbitrary "application ID," which are used to initialize the HKDF. Then you can provide a `BinaryId` to the `KeyGenerator` to create `ECDH` and `ECDSA` keys.

The `KeyGenerator` can also generate symmetric keys for encrypting items in your database with unique keys.

## Key storage

This library elimintates the necessity to store any keys generated by the `KeyGenerator` since they can be derived with the internal HKDF. There is only one key that needs to be saved, and that is the HMAC Key or PRK that is used within the HKDF. This is as secure as hard-coding any other type of private key. Some Key IDs might need to be stored, but they are not sensitive. 

## Key lifetimes

The `BinaryId` struct can accept a version number, which will be encoded in its metadata. The metadata is currently only 1 byte, and the maximum supported version is only 63, but this might change to use 2 bytes instead of 1 for the metadata. The version number can be changed to update the HMAC key or hash algorithm, or almost any other aspect about the ID or key generation mechanism. The only thing that you can't change easily between versions is the index of the metadata byte.

The `BinaryId` can also contain a 3-byte timestamp marking the expiration of the key ID. The compressed timestamp has the following limitations:
* it cannot represent a date further than 136 years from the `EPOCH` value you supply (which can be any past timestamp, refer to the `BinaryId` documentation)
* the timestamp will always be between 129-384 seconds ahead of the input expiration timestamp. This is useful for providing a small time extension.
* Timestamp validation requires the `std` feature. If this feature is disabled, an expired ID will pass validation, but there is a `get_expiration_time` method for decoding the expiration time if you have a way to get the current time.

## Switching between signature algorithms and hash functions for key generation

You could switch the version of your IDs to update some aspects of your cryptography, such as the:
* signature algorithm
* ID size
* hash function
* HMAC key
* `EPOCH` timestamp used in the compression

You will need to use the `get_version` method to attempt to extract the ID's version.